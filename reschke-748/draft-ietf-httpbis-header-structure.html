<!DOCTYPE html>
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Structured Headers for HTTP</title><script>
function anchorRewrite() {
  map = { };
  if (window.location.hash.length >= 1) {
    var fragid = window.location.hash.substr(1);
    if (fragid) {
      if (! document.getElementById(fragid)) {
        var prefix = "rfc.";
        var mapped = map[fragid];
        if (mapped) {
          window.location.hash = mapped;
        } else if (fragid.indexOf("section-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(8);
        } else if (fragid.indexOf("appendix-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(9);
        } else if (fragid.indexOf("s-") == 0) {
          var postfix = fragid.substring(2);
          if (postfix.startsWith("abstract")) {
            window.location.hash = prefix + postfix;
          } else if (postfix.startsWith("note-")) {
            window.location.hash = prefix + "note." + postfix.substring(5);
          } else {
            window.location.hash = prefix + "section." + postfix;
          }
        } else if (fragid.indexOf("p-") == 0) {
          var r = fragid.substring(2);
          var p = r.indexOf("-");
          if (p >= 0) {
            window.location.hash = prefix + "section." + r.substring(0, p) + ".p." + r.substring(p + 1);
          }
        }
      }
    }  
  }
}
window.addEventListener('hashchange', anchorRewrite);
window.addEventListener('DOMContentLoaded', anchorRewrite);
</script>
<style type="text/css">/*<![CDATA[*/

body {
  font: 16px "Helvetica Neue","Open Sans",Helvetica,Calibri,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 24px;
  margin: 75px auto;
  max-width: 624px;
  padding: 0 5px;
}

.title, .filename, h1, h2, h3, h4, h5 {
  font: 16px "Roboto Condensed","Helvetica Neue","Open Sans",Helvetica,Calibri,sans-serif;
  font-size-adjust: 0.5;
  font-weight: bold;
  color: #333;
  line-height: 100%;
  margin: 1.2em 0 0.3em;
}
.title, #rfc\.title h1 { font-size: 32px; }
h1, section h1, h2, section h2, section h3, nav h2 { font-size: 20px; }
h3, section h4, h4, section h5 { font-size: 16px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header, table#rfc\.headerblock {
  width: 100%;
}
table.header td, table#rfc\.headerblock td {
  border: none;
  background-color: transparent;
  color: black;
  padding: 0;
}
.filename {
  display: block;
  color: rgb(119, 119, 119);
  font-size: 20px;
  font-weight: normal;
  line-height: 100%;
  margin: 10px 0 32px;
}
#rfc\.abstract+p, #rfc\.abstract p {
  font-size: 20px;
  line-height: 28px;
}

samp, tt, code, pre, span.tt {
  font: 13.5px Consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure, caption {
  font-style: italic;
  margin: 0 1.5em;
  text-align: left;
}

address {
  margin: 16px 2px;
  line-height: 20px;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn, address b {
  font-weight: normal;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}
hr.noprint {
  display: none;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

p, ol, ul, li {
  padding: 0;
}
p {
  margin: 0.5em 0;
}
ol, ul {
  margin: 0.2em 0 0.2em 2em;
}
li {
  margin: 0.2em 0;
}
address {
  font-style: normal;
}

ul.toc ul {
  margin: 0 0 0 2em;
}
ul.toc li {
  list-style: none;
  margin: 0;
}

@media screen and (min-width: 924px) {
  body {
    padding-right: 350px;
  }
  body>ul.toc, body>#rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    z-index: 1;
    overflow: auto;
    overscroll-behavior: contain;
  }
  body>#rfc\.toc {
    top: 55px;
  }
  body>ul.toc {
    top: 100px;
  }

  ul.toc {
    margin: 0 0 0 4px;
    font-size: 12px;
    line-height: 20px;
  }
  ul.toc ul {
    margin-left: 1.2em;
  }
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>
  <meta name="viewport" content="initial-scale=1.0">
<link rel="Contents" href="#rfc.toc"><link rel="Author" href="#rfc.authors"><link rel="License" href="#rfc.copyrightnotice"><link rel="Chapter" title="1 Introduction" href="#rfc.section.1"><link rel="Chapter" title="2 Defining New Structured Headers" href="#rfc.section.2"><link rel="Chapter" title="3 Structured Header Data Types" href="#rfc.section.3"><link rel="Chapter" title="4 Structured Headers in HTTP/1" href="#rfc.section.4"><link rel="Chapter" title="5 IANA Considerations" href="#rfc.section.5"><link rel="Chapter" title="6 Security Considerations" href="#rfc.section.6"><link rel="Chapter" href="#rfc.section.7" title="7 References"><link rel="Appendix" title="A Acknowledgements" href="#rfc.section.A"><link rel="Appendix" title="B Frequently Asked Questions" href="#rfc.section.B"><link rel="Appendix" title="C Changes" href="#rfc.section.C"><meta name="viewport" content="initial-scale=1"><meta name="generator" content="http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.1052, 2019/01/04 11:24:28, XSLT vendor: libxslt http://xmlsoft.org/XSLT/, via: https://github.com/cabo/kramdown-rfc2629 version 1.2.9"><meta name="keywords" content="Internet-Draft"><link rel="schema.dcterms" href="http://purl.org/dc/terms/"><meta name="dcterms.creator" content="Nottingham, M."><meta name="dcterms.creator" content="Kamp, P-H."><meta name="dcterms.issued" content="2019-01-15"><meta name="dcterms.abstract" content="This document describes a set of data types and algorithms associated with them that are intended to make it easier and safer to define and handle HTTP header fields. It is intended for use by new specifications of HTTP header fields as well as revisions of existing header field specifications when doing so does not cause interoperability issues."><meta name="description" content="This document describes a set of data types and algorithms associated with them that are intended to make it easier and safer to define and handle HTTP header fields. It is intended for use by new specifications of HTTP header fields as well as revisions of existing header field specifications when doing so does not cause interoperability issues."></head><body><header><table class="header" id="rfc.headerblock"><tbody><tr><td class="left">HTTP Working Group</td><td class="right">M. Nottingham</td></tr><tr><td class="left">Internet-Draft</td><td class="right">Fastly</td></tr><tr><td class="left">Intended status: Standards Track</td><td class="right">P-H. Kamp</td></tr><tr><td class="left">Expires: July 19, 2019</td><td class="right">The Varnish Cache Project</td></tr><tr><td class="left"></td><td class="right">January 15, 2019</td></tr></tbody></table><div id="rfc.title"><h1>Structured Headers for HTTP</h1><div class="filename"><a href="https://datatracker.ietf.org/doc/draft-ietf-httpbis-header-structure" class="smpl">draft-ietf-httpbis-header-structure-latest</a></div></div></header><section id="rfc.abstract"><h2><a href="#rfc.abstract">Abstract</a></h2><div id="rfc.abstract.p.1"><p>This document describes a set of data types and algorithms associated with them that are intended to make it easier and safer to define and handle HTTP header fields. It is intended for use by new specifications of HTTP header fields as well as revisions of existing header field specifications when doing so does not cause interoperability issues.</p></div></section><section id="rfc.note.1" class="note"><h2><a href="#rfc.note.1">Note to Readers</a></h2><div id="rfc.note.1.p.1"><p><em>RFC EDITOR: please remove this section before publication</em></p></div><div id="rfc.note.1.p.2"><p>Discussion of this draft takes place on the HTTP working group mailing list (ietf-http-wg@w3.org), which is archived at <a href="https://lists.w3.org/Archives/Public/ietf-http-wg/">https://lists.w3.org/Archives/Public/ietf-http-wg/</a>.</p></div><div id="rfc.note.1.p.3"><p>Working Group information can be found at <a href="https://httpwg.github.io/">https://httpwg.github.io/</a>; source code and issues list for this draft can be found at <a href="https://github.com/httpwg/http-extensions/labels/header-structure">https://github.com/httpwg/http-extensions/labels/header-structure</a>.</p></div><div id="rfc.note.1.p.4"><p>Tests for implementations are collected at <a href="https://github.com/httpwg/structured-header-tests">https://github.com/httpwg/structured-header-tests</a>.</p></div><div id="rfc.note.1.p.5"><p>Implementations are tracked at <a href="https://github.com/httpwg/wiki/wiki/Structured-Headers">https://github.com/httpwg/wiki/wiki/Structured-Headers</a>.</p></div></section><section id="rfc.status"><h2><a href="#rfc.status">Status of this Memo</a></h2><div id="rfc.boilerplate.1.p.1"><p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p></div><div id="rfc.boilerplate.1.p.2"><p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF). Note that other groups may also distribute working documents as Internet-Drafts. The list of current Internet-Drafts is at <a href="http://datatracker.ietf.org/drafts/current/">http://datatracker.ietf.org/drafts/current/</a>.</p></div><div id="rfc.boilerplate.1.p.3"><p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time. It is inappropriate to use Internet-Drafts as reference material or to cite them other than as “work in progress”.</p></div><div id="rfc.boilerplate.1.p.4"><p>This Internet-Draft will expire on July 19, 2019.</p></div></section><section id="rfc.copyrightnotice"><h2><a href="#rfc.copyrightnotice">Copyright Notice</a></h2><div id="rfc.boilerplate.2.p.1"><p>Copyright © 2019 IETF Trust and the persons identified as the document authors. All rights reserved.</p></div><div id="rfc.boilerplate.2.p.2"><p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p></div></section><hr class="noprint"><nav id="rfc.toc"><h2 class="np"><a href="#rfc.toc">Table of Contents</a></h2><ul class="toc"><li><a href="#rfc.section.1">1.</a>   <a href="#introduction">Introduction</a><ul><li><a href="#rfc.section.1.1">1.1.</a>   <a href="#strict">Intentionally Strict Processing</a></li><li><a href="#rfc.section.1.2">1.2.</a>   <a href="#notational-conventions">Notational Conventions</a></li></ul></li><li><a href="#rfc.section.2">2.</a>   <a href="#specify">Defining New Structured Headers</a></li><li><a href="#rfc.section.3">3.</a>   <a href="#types">Structured Header Data Types</a><ul><li><a href="#rfc.section.3.1">3.1.</a>   <a href="#dictionary">Dictionaries</a></li><li><a href="#rfc.section.3.2">3.2.</a>   <a href="#list">Lists</a></li><li><a href="#rfc.section.3.3">3.3.</a>   <a href="#listlist">Lists of Lists</a></li><li><a href="#rfc.section.3.4">3.4.</a>   <a href="#param">Parameterised Lists</a></li><li><a href="#rfc.section.3.5">3.5.</a>   <a href="#item">Items</a></li><li><a href="#rfc.section.3.6">3.6.</a>   <a href="#integer">Integers</a></li><li><a href="#rfc.section.3.7">3.7.</a>   <a href="#float">Floats</a></li><li><a href="#rfc.section.3.8">3.8.</a>   <a href="#string">Strings</a></li><li><a href="#rfc.section.3.9">3.9.</a>   <a href="#token">Tokens</a></li><li><a href="#rfc.section.3.10">3.10.</a>   <a href="#binary">Byte Sequences</a></li><li><a href="#rfc.section.3.11">3.11.</a>   <a href="#boolean">Booleans</a></li></ul></li><li><a href="#rfc.section.4">4.</a>   <a href="#text">Structured Headers in HTTP/1</a><ul><li><a href="#rfc.section.4.1">4.1.</a>   <a href="#text-serialise">Serialising Structured Headers into HTTP/1</a></li><li><a href="#rfc.section.4.2">4.2.</a>   <a href="#text-parse">Parsing HTTP/1 Header Fields into Structured Headers</a></li></ul></li><li><a href="#rfc.section.5">5.</a>   <a href="#iana-considerations">IANA Considerations</a></li><li><a href="#rfc.section.6">6.</a>   <a href="#security-considerations">Security Considerations</a></li><li><a href="#rfc.section.7">7.</a>   <a href="#rfc.references">References</a><ul><li><a href="#rfc.section.7.1">7.1.</a>   <a href="#rfc.references.1">Normative References</a></li><li><a href="#rfc.section.7.2">7.2.</a>   <a href="#rfc.references.2">Informative References</a></li></ul></li><li><a href="#rfc.section.A">A.</a>   <a href="#acknowledgements">Acknowledgements</a></li><li><a href="#rfc.section.B">B.</a>   <a href="#faq">Frequently Asked Questions</a><ul><li><a href="#rfc.section.B.1">B.1.</a>   <a href="#why-not-json">Why not JSON?</a></li><li><a href="#rfc.section.B.2">B.2.</a>   <a href="#structured-headers-dont-fit-my-data">Structured Headers don’t “fit” my data.</a></li><li><a href="#rfc.section.B.3">B.3.</a>   <a href="#what-should-generic-structured-headers-implementations-expose">What should generic Structured Headers implementations expose?</a></li></ul></li><li><a href="#rfc.section.C">C.</a>   <a href="#changes">Changes</a><ul><li><a href="#rfc.section.C.1">C.1.</a>   <a href="#since-draft-ietf-httpbis-header-structure-08">Since draft-ietf-httpbis-header-structure-08</a></li><li><a href="#rfc.section.C.2">C.2.</a>   <a href="#since-draft-ietf-httpbis-header-structure-07">Since draft-ietf-httpbis-header-structure-07</a></li><li><a href="#rfc.section.C.3">C.3.</a>   <a href="#since-draft-ietf-httpbis-header-structure-06">Since draft-ietf-httpbis-header-structure-06</a></li><li><a href="#rfc.section.C.4">C.4.</a>   <a href="#since-draft-ietf-httpbis-header-structure-05">Since draft-ietf-httpbis-header-structure-05</a></li><li><a href="#rfc.section.C.5">C.5.</a>   <a href="#since-draft-ietf-httpbis-header-structure-04">Since draft-ietf-httpbis-header-structure-04</a></li><li><a href="#rfc.section.C.6">C.6.</a>   <a href="#since-draft-ietf-httpbis-header-structure-03">Since draft-ietf-httpbis-header-structure-03</a></li><li><a href="#rfc.section.C.7">C.7.</a>   <a href="#since-draft-ietf-httpbis-header-structure-02">Since draft-ietf-httpbis-header-structure-02</a></li><li><a href="#rfc.section.C.8">C.8.</a>   <a href="#since-draft-ietf-httpbis-header-structure-01">Since draft-ietf-httpbis-header-structure-01</a></li><li><a href="#rfc.section.C.9">C.9.</a>   <a href="#since-draft-ietf-httpbis-header-structure-00">Since draft-ietf-httpbis-header-structure-00</a></li></ul></li><li><a href="#rfc.authors">Authors' Addresses</a></li></ul></nav><section id="introduction"><h2 id="rfc.section.1" class="np"><a href="#rfc.section.1">1.</a> <a href="#introduction">Introduction</a></h2><div id="rfc.section.1.p.1"><p>Specifying the syntax of new HTTP header fields is an onerous task; even with the guidance in <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>, Section 8.3.1, there are many decisions – and pitfalls – for a prospective HTTP header field author.</p></div><div id="rfc.section.1.p.2"><p>Once a header field is defined, bespoke parsers and serialisers often need to be written, because each header has slightly different handling of what looks like common syntax.</p></div><div id="rfc.section.1.p.3"><p>This document introduces a set of common data structures for use in HTTP header field values to address these problems. In particular, it defines a generic, abstract model for header field values, along with a concrete serialisation for expressing that model in HTTP/1 <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a> header fields.</p></div><div id="rfc.section.1.p.4"><p>HTTP headers that are defined as “Structured Headers” use the types defined in this specification to define their syntax and basic handling rules, thereby simplifying both their definition by specification writers and handling by implementations.</p></div><div id="rfc.section.1.p.5"><p>Additionally, future versions of HTTP can define alternative serialisations of the abstract model of these structures, allowing headers that use it to be transmitted more efficiently without being redefined.</p></div><div id="rfc.section.1.p.6"><p>Note that it is not a goal of this document to redefine the syntax of existing HTTP headers; the mechanisms described herein are only intended to be used with headers that explicitly opt into them.</p></div><div id="rfc.section.1.p.7"><p>To specify a header field that is a Structured Header, see <a href="#specify" title="Defining New Structured Headers">Section 2</a>.</p></div><div id="rfc.section.1.p.8"><p><a href="#types" title="Structured Header Data Types">Section 3</a> defines a number of abstract data types that can be used in Structured Headers.</p></div><div id="rfc.section.1.p.9"><p>Those abstract types can be serialised into and parsed from textual headers – such as those used in HTTP/1 – using the algorithms described in <a href="#text" title="Structured Headers in HTTP/1">Section 4</a>.</p></div><section id="strict"><h3 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1.</a> <a href="#strict">Intentionally Strict Processing</a></h3><div id="rfc.section.1.1.p.1"><p>This specification intentionally defines strict parsing and serialisation behaviours using step-by-step algorithms; the only error handling defined is to fail the operation altogether.</p></div><div id="rfc.section.1.1.p.2"><p>This is designed to encourage faithful implementation and therefore good interoperability. Therefore, implementations that try to be “helpful” by being more tolerant of input are doing a disservice to the overall community, since it will encourage other implementations to implement similar (but likely subtly different) workarounds.</p></div><div id="rfc.section.1.1.p.3"><p>In other words, strict processing is an intentional feature of this specification; it allows non-conformant input to be discovered and corrected early, and avoids both interoperability and security issues that might otherwise result.</p></div><div id="rfc.section.1.1.p.4"><p>Note that as a result of this strictness, if a header field is appended to by multiple parties (e.g., intermediaries, or different components in the sender), it could be that an error in one party’s value causes the entire header field to fail parsing.</p></div></section><section id="notational-conventions"><h3 id="rfc.section.1.2"><a href="#rfc.section.1.2">1.2.</a> <a href="#notational-conventions">Notational Conventions</a></h3><div id="rfc.section.1.2.p.1"><p>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in BCP 14 <a href="#RFC2119"><cite title="Key words for use in RFCs to Indicate Requirement Levels">[RFC2119]</cite></a> <a href="#RFC8174"><cite title="Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words">[RFC8174]</cite></a> when, and only when, they appear in all capitals, as shown here.</p></div><div id="rfc.section.1.2.p.2"><p>This document uses the Augmented Backus-Naur Form (ABNF) notation of <a href="#RFC5234"><cite title="Augmented BNF for Syntax Specifications: ABNF">[RFC5234]</cite></a>, including the VCHAR, SP, DIGIT, ALPHA and DQUOTE rules from that document. It also includes the OWS rule from <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>.</p></div><div id="rfc.section.1.2.p.3"><p>This document uses algorithms to specify parsing and serialisation behaviours, and ABNF to illustrate expected syntax in HTTP/1-style header fields.</p></div><div id="rfc.section.1.2.p.4"><p>For parsing from HTTP/1 header fields, implementations MUST follow the algorithms, but MAY vary in implementation so as the behaviours are indistinguishable from specified behaviour. If there is disagreement between the parsing algorithms and ABNF, the specified algorithms take precedence. In some places, the algorithms are “greedy” with whitespace, but this should not affect conformance.</p></div><div id="rfc.section.1.2.p.5"><p>For serialisation to HTTP/1 header fields, the ABNF illustrates the range of acceptable wire representations with as much fidelity as possible, and the algorithms define the recommended way to produce them. Implementations MAY vary from the specified behaviour so long as the output still matches the ABNF.</p></div></section></section><section id="specify"><h2 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#specify">Defining New Structured Headers</a></h2><div id="rfc.section.2.p.1" class="avoidbreakafter"><p>To define a HTTP header as a structured header, its specification needs to:</p></div><div id="rfc.section.2.p.2"><ul><li>Reference this specification. Recipients and generators of the header need to know that the requirements of this document are in effect.</li><li>Specify the header field’s allowed syntax for values, in terms of the types described in <a href="#types" title="Structured Header Data Types">Section 3</a>, along with their associated semantics. Syntax definitions are encouraged to use the ABNF rules beginning with “sh-“ defined in this specification.</li><li>Specify any additional constraints upon the syntax of the structured used, as well as the consequences when those constraints are violated. When Structured Headers parsing fails, the header is discarded (see <a href="#text-parse" title="Parsing HTTP/1 Header Fields into Structured Headers">Section 4.2</a>); in most situations, header-specific constraints should do likewise.</li></ul></div><div id="rfc.section.2.p.3"><p>Note that a header field definition cannot relax the requirements of a structure or its processing because doing so would preclude handling by generic software; they can only add additional constraints. Likewise, header field definitions should use Structured Headers for the entire header field value, not a portion thereof.</p></div><div id="rfc.section.2.p.4" class="avoidbreakafter"><p>For example:</p></div><div id="rfc.figure.u.1"><pre class="text">
# Foo-Example Header

The Foo-Example HTTP header field conveys information about how
much Foo the message has.

Foo-Example is a Structured Header [RFCxxxx]. Its value MUST be a
dictionary ([RFCxxxx], Section Y.Y). Its ABNF is:

  Foo-Example = sh-dictionary

The dictionary MUST contain:

* Exactly one member whose key is "foo", and whose value is an
  integer ([RFCxxxx], Section Y.Y), indicating the number of foos
  in the message.
* Exactly one member whose key is "barUrls", and whose value is a
  string ([RFCxxxx], Section Y.Y), conveying the Bar URLs for the
  message. See below for processing requirements.

If the parsed header field does not contain both, it MUST be
ignored.

"foo" MUST be between 0 and 10, inclusive; other values MUST cause
the header to be ignored.

"barUrls" contains a space-separated list of URI-references
([RFC3986], Section 4.1):

   barURLs = URI-reference *( 1*SP URI-reference )

If a member of barURLs is not a valid URI-reference, it MUST cause
that value to be ignored.

If a member of barURLs is a relative reference ([RFC3986],
Section 4.2), it MUST be resolved ([RFC3986], Section 5) before
being used.
</pre></div><div id="rfc.section.2.p.5"><p>This specification defines minimums for the length or number of various structures supported by Structured Headers implementations. It does not specify maximum sizes in most cases, but header authors should be aware that HTTP implementations do impose various limits on the size of individual header fields, the total number of fields, and/or the size of the entire header block.</p></div></section><section id="types"><h2 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#types">Structured Header Data Types</a></h2><div id="rfc.section.3.p.1"><p>This section defines the abstract value types that can be composed into Structured Headers. The ABNF provided represents the on-wire format in HTTP/1.</p></div><section id="dictionary"><h3 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a> <a href="#dictionary">Dictionaries</a></h3><div id="rfc.section.3.1.p.1"><p>Dictionaries are ordered maps of key-value pairs, where the keys are short, textual strings and the values are items (<a href="#item" title="Items">Section 3.5</a>). There can be one or more members, and keys are required to be unique.</p></div><div id="rfc.section.3.1.p.2"><p>Implementations MUST provide access to dictionaries both by index and by key. Specifications MAY use either means of accessing the members.</p></div><div id="rfc.section.3.1.p.3" class="avoidbreakafter"><p>The ABNF for dictionaries in HTTP/1 headers is:</p></div><div id="rfc.figure.u.2"><pre class="inline">
sh-dictionary  = dict-member *( OWS "," OWS dict-member )
dict-member    = member-name "=" member-value
member-name    = key
member-value   = sh-item
key            = lcalpha *( lcalpha / DIGIT / "_" / "-" )
lcalpha        = %x61-7A ; a-z
</pre></div><div id="rfc.section.3.1.p.4" class="avoidbreakafter"><p>In HTTP/1, keys and values are separated by “=” (without whitespace), and key/value pairs are separated by a comma with optional whitespace. For example:</p></div><div id="rfc.figure.u.3"><pre class="text">
Example-DictHeader: en="Applepie", da=*w4ZibGV0w6ZydGU=*
</pre></div><div id="rfc.section.3.1.p.5"><p>Typically, a header field specification will define the semantics of individual keys, as well as whether their presence is required or optional. Recipients MUST ignore keys that are undefined or unknown, unless the header field’s specification specifically disallows them.</p></div><div id="rfc.section.3.1.p.6"><p>Parsers MUST support dictionaries containing at least 1024 key/value pairs, and dictionary keys with at least 64 characters.</p></div></section><section id="list"><h3 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2.</a> <a href="#list">Lists</a></h3><div id="rfc.section.3.2.p.1"><p>Lists are arrays of items (<a href="#item" title="Items">Section 3.5</a>) with one or more members.</p></div><div id="rfc.section.3.2.p.2" class="avoidbreakafter"><p>The ABNF for lists in HTTP/1 headers is:</p></div><div id="rfc.figure.u.4"><pre class="inline">
sh-list     = list-member *( OWS "," OWS list-member )
list-member = sh-item
</pre></div><div id="rfc.section.3.2.p.3" class="avoidbreakafter"><p>In HTTP/1, each member is separated by a comma and optional whitespace. For example, a header field whose value is defined as a list of strings could look like:</p></div><div id="rfc.figure.u.5"><pre class="text">
Example-StrListHeader: "foo", "bar", "It was the best of times."
</pre></div><div id="rfc.section.3.2.p.4"><p>Header specifications can constrain the types of individual values if necessary.</p></div><div id="rfc.section.3.2.p.5"><p>Parsers MUST support lists containing at least 1024 members.</p></div></section><section id="listlist"><h3 id="rfc.section.3.3"><a href="#rfc.section.3.3">3.3.</a> <a href="#listlist">Lists of Lists</a></h3><div id="rfc.section.3.3.p.1"><p>Lists of Lists are arrays of arrays containing items (<a href="#item" title="Items">Section 3.5</a>).</p></div><div id="rfc.section.3.3.p.2" class="avoidbreakafter"><p>The ABNF for lists of lists in HTTP/1 headers is:</p></div><div id="rfc.figure.u.6"><pre class="inline">
sh-listlist = inner-list *( OWS "," OWS inner-list )
inner-list  = list-member *( OWS ";" OWS list-member )
</pre></div><div id="rfc.section.3.3.p.3" class="avoidbreakafter"><p>In HTTP/1, each inner-list is separated by a comma and optional whitespace, and members of the inner-list are separated by semicolons and optional whitespace. For example, a header field whose value is defined as a list of lists of strings could look like:</p></div><div id="rfc.figure.u.7"><pre class="text">
Example-StrListListHeader: "foo";"bar", "baz", "bat"; "one"
</pre></div><div id="rfc.section.3.3.p.4"><p>Header specifications can constrain the types of individual inner-list values if necessary.</p></div><div id="rfc.section.3.3.p.5"><p>Parsers MUST support lists of lists containing at least 1024 members, and inner-lists containing at least 256 members.</p></div></section><section id="param"><h3 id="rfc.section.3.4"><a href="#rfc.section.3.4">3.4.</a> <a href="#param">Parameterised Lists</a></h3><div id="rfc.section.3.4.p.1"><p>Parameterised Lists are arrays of parameterised identifier with one or more members.</p></div><div id="rfc.section.3.4.p.2"><p>A parameterised identifier is a token (<a href="#token" title="Tokens">Section 3.9</a>}) with an optional set of parameters, each parameter having a textual name and an optional value that is an item (<a href="#item" title="Items">Section 3.5</a>). Ordering between parameters is not significant, and duplicate parameters MUST cause parsing to fail.</p></div><div id="rfc.section.3.4.p.3" class="avoidbreakafter"><p>The ABNF for parameterised lists in HTTP/1 headers is:</p></div><div id="rfc.figure.u.8"><pre class="inline">
sh-param-list = param-item *( OWS "," OWS param-item )
param-item    = primary-id *parameter
primary-id    = sh-token
parameter     = OWS ";" OWS param-name [ "=" param-value ]
param-name    = key
param-value   = sh-item
</pre></div><div id="rfc.section.3.4.p.4" class="avoidbreakafter"><p>In HTTP/1, each param-id is separated by a comma and optional whitespace (as in Lists), and the parameters are separated by semicolons. For example:</p></div><div id="rfc.figure.u.9"><pre class="text">
Example-ParamListHeader: abc_123;a=1;b=2; cdef_456, ghi;q="9";r="w"
</pre></div><div id="rfc.section.3.4.p.5"><p>Parsers MUST support parameterised lists containing at least 1024 members, support members with at least 256 parameters, and support parameter keys with at least 64 characters.</p></div></section><section id="item"><h3 id="rfc.section.3.5"><a href="#rfc.section.3.5">3.5.</a> <a href="#item">Items</a></h3><div id="rfc.section.3.5.p.1"><p>An item is can be a integer (<a href="#integer" title="Integers">Section 3.6</a>), float (<a href="#float" title="Floats">Section 3.7</a>), string (<a href="#string" title="Strings">Section 3.8</a>), token (<a href="#token" title="Tokens">Section 3.9</a>}), byte sequence (<a href="#binary" title="Byte Sequences">Section 3.10</a>), or Boolean (<a href="#boolean" title="Booleans">Section 3.11</a>).</p></div><div id="rfc.section.3.5.p.2" class="avoidbreakafter"><p>The ABNF for items in HTTP/1 headers is:</p></div><div id="rfc.figure.u.10"><pre class="inline">
sh-item = sh-integer / sh-float / sh-string / sh-token / sh-binary
          / sh-boolean
</pre></div></section><section id="integer"><h3 id="rfc.section.3.6"><a href="#rfc.section.3.6">3.6.</a> <a href="#integer">Integers</a></h3><div id="rfc.section.3.6.p.1"><p>Integers have a range of −9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 inclusive (i.e., a 64-bit signed integer).</p></div><div id="rfc.section.3.6.p.2" class="avoidbreakafter"><p>The ABNF for integers in HTTP/1 headers is:</p></div><div id="rfc.figure.u.11"><pre class="inline">
sh-integer = ["-"] 1*19DIGIT
</pre></div><div id="rfc.section.3.6.p.3" class="avoidbreakafter"><p>For example:</p></div><div id="rfc.figure.u.12"><pre class="text">
Example-IntegerHeader: 42
</pre></div></section><section id="float"><h3 id="rfc.section.3.7"><a href="#rfc.section.3.7">3.7.</a> <a href="#float">Floats</a></h3><div id="rfc.section.3.7.p.1"><p>Floats are integers with a fractional part, that can be stored as IEEE 754 double precision numbers (binary64) (<a href="#IEEE754"><cite title="IEEE Standard for Floating-Point Arithmetic">[IEEE754]</cite></a>).</p></div><div id="rfc.section.3.7.p.2" class="avoidbreakafter"><p>The ABNF for floats in HTTP/1 headers is:</p></div><div id="rfc.figure.u.13"><pre class="inline">
sh-float    = ["-"] (
             DIGIT "." 1*14DIGIT /
            2DIGIT "." 1*13DIGIT /
            3DIGIT "." 1*12DIGIT /
            4DIGIT "." 1*11DIGIT /
            5DIGIT "." 1*10DIGIT /
            6DIGIT "." 1*9DIGIT /
            7DIGIT "." 1*8DIGIT /
            8DIGIT "." 1*7DIGIT /
            9DIGIT "." 1*6DIGIT /
           10DIGIT "." 1*5DIGIT /
           11DIGIT "." 1*4DIGIT /
           12DIGIT "." 1*3DIGIT /
           13DIGIT "." 1*2DIGIT /
           14DIGIT "." 1DIGIT )
</pre></div><div id="rfc.section.3.7.p.3" class="avoidbreakafter"><p>For example, a header whose value is defined as a float could look like:</p></div><div id="rfc.figure.u.14"><pre class="text">
Example-FloatHeader: 4.5
</pre></div></section><section id="string"><h3 id="rfc.section.3.8"><a href="#rfc.section.3.8">3.8.</a> <a href="#string">Strings</a></h3><div id="rfc.section.3.8.p.1"><p>Strings are zero or more printable ASCII <a href="#RFC0020"><cite title="ASCII format for network interchange">[RFC0020]</cite></a> characters (i.e., the range 0x20 to 0x7E). Note that this excludes tabs, newlines, carriage returns, etc.</p></div><div id="rfc.section.3.8.p.2" class="avoidbreakafter"><p>The ABNF for strings in HTTP/1 headers is:</p></div><div id="rfc.figure.u.15"><pre class="inline">
sh-string = DQUOTE *(chr) DQUOTE
chr       = unescaped / escaped
unescaped = %x20-21 / %x23-5B / %x5D-7E
escaped   = "\" ( DQUOTE / "\" )
</pre></div><div id="rfc.section.3.8.p.3" class="avoidbreakafter"><p>In HTTP/1 headers, strings are delimited with double quotes, using a backslash (“\”) to escape double quotes and backslashes. For example:</p></div><div id="rfc.figure.u.16"><pre class="text">
Example-StringHeader: "hello world"
</pre></div><div id="rfc.section.3.8.p.4"><p>Note that strings only use DQUOTE as a delimiter; single quotes do not delimit strings. Furthermore, only DQUOTE and “\” can be escaped; other sequences MUST cause parsing to fail.</p></div><div id="rfc.section.3.8.p.5"><p>Unicode is not directly supported in this document, because it causes a number of interoperability issues, and – with few exceptions – header values do not require it.</p></div><div id="rfc.section.3.8.p.6"><p>When it is necessary for a field value to convey non-ASCII string content, a byte sequence (<a href="#binary" title="Byte Sequences">Section 3.10</a>) SHOULD be specified, along with a character encoding (preferably UTF-8).</p></div><div id="rfc.section.3.8.p.7"><p>Parsers MUST support strings with at least 1024 characters.</p></div></section><section id="token"><h3 id="rfc.section.3.9"><a href="#rfc.section.3.9">3.9.</a> <a href="#token">Tokens</a></h3><div id="rfc.section.3.9.p.1"><p>Tokens are short textual words; their abstract model is identical to their expression in the textual HTTP serialisation.</p></div><div id="rfc.section.3.9.p.2" class="avoidbreakafter"><p>The ABNF for tokens in HTTP/1 headers is:</p></div><div id="rfc.figure.u.17"><pre class="inline">
sh-token = ALPHA *( ALPHA / DIGIT / "_" / "-" / "." / ":" / "%" / "*" / "/" )
</pre></div><div id="rfc.section.3.9.p.3"><p>Parsers MUST support tokens with at least 512 characters.</p></div><div id="rfc.section.3.9.p.4"><p>Note that a Structured Header token is not the same as the “token” ABNF rule defined in <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>.</p></div></section><section id="binary"><h3 id="rfc.section.3.10"><a href="#rfc.section.3.10">3.10.</a> <a href="#binary">Byte Sequences</a></h3><div id="rfc.section.3.10.p.1"><p>Byte sequences can be conveyed in Structured Headers.</p></div><div id="rfc.section.3.10.p.2" class="avoidbreakafter"><p>The ABNF for a byte sequence in HTTP/1 headers is:</p></div><div id="rfc.figure.u.18"><pre class="inline">
sh-binary = "*" *(base64) "*"
base64    = ALPHA / DIGIT / "+" / "/" / "="
</pre></div><div id="rfc.section.3.10.p.3" class="avoidbreakafter"><p>In HTTP/1 headers, a byte sequence is delimited with asterisks and encoded using base64 (<a href="#RFC4648"><cite title="The Base16, Base32, and Base64 Data Encodings">[RFC4648]</cite></a>, Section 4). For example:</p></div><div id="rfc.figure.u.19"><pre class="text">
Example-BinaryHdr: *cHJldGVuZCB0aGlzIGlzIGJpbmFyeSBjb250ZW50Lg==*
</pre></div><div id="rfc.section.3.10.p.4"><p>Parsers MUST support byte sequences with at least 16384 octets after decoding.</p></div></section><section id="boolean"><h3 id="rfc.section.3.11"><a href="#rfc.section.3.11">3.11.</a> <a href="#boolean">Booleans</a></h3><div id="rfc.section.3.11.p.1"><p>Boolean values can be conveyed in Structured Headers.</p></div><div id="rfc.section.3.11.p.2" class="avoidbreakafter"><p>The ABNF for a Boolean in HTTP/1 headers is:</p></div><div id="rfc.figure.u.20"><pre class="inline">
sh-boolean = "?" boolean
boolean    = %54 / %46  ; capital "T" or "F"
</pre></div><div id="rfc.section.3.11.p.3" class="avoidbreakafter"><p>In HTTP/1 headers, a byte sequence is indicated with a leading “?” character. For example:</p></div><div id="rfc.figure.u.21"><pre class="text">
Example-BoolHdr: ?T
</pre></div></section></section><section id="text"><h2 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#text">Structured Headers in HTTP/1</a></h2><div id="rfc.section.4.p.1"><p>This section defines how to serialise and parse Structured Headers in HTTP/1 textual header fields, and protocols compatible with them (e.g., in HTTP/2 <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a> before HPACK <a href="#RFC7541"><cite title="HPACK: Header Compression for HTTP/2">[RFC7541]</cite></a> is applied).</p></div><section id="text-serialise"><h3 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1.</a> <a href="#text-serialise">Serialising Structured Headers into HTTP/1</a></h3><div id="rfc.section.4.1.p.1" class="avoidbreakafter"><p>Given a structured defined in this specification:</p></div><div id="rfc.section.4.1.p.2"><ol><li>If the structure is a dictionary, return the result of Serialising a Dictionary (<a href="#ser-dictionary" title="Serialising a Dictionary">Section 4.1.1</a>).</li><li>If the structure is a parameterised list, return the result of Serialising a Parameterised List (<a href="#ser-param-list" title="Serialising a Parameterised List">Section 4.1.4</a>).</li><li>If the structure is a list of lists, return the result of Serialising a List of Lists ({ser-listlist}).</li><li>If the structure is a list, return the result of Serialising a List <a href="#ser-list" title="Serialising a List">Section 4.1.2</a>.</li><li>If the structure is an item, return the result of Serialising an Item (<a href="#ser-item" title="Serialising an Item">Section 4.1.5</a>).</li><li>Otherwise, fail serialisation.</li></ol></div><section id="ser-dictionary"><h4 id="rfc.section.4.1.1"><a href="#rfc.section.4.1.1">4.1.1.</a> <a href="#ser-dictionary">Serialising a Dictionary</a></h4><div id="rfc.section.4.1.1.p.1" class="avoidbreakafter"><p>Given a dictionary as input_dictionary:</p></div><div id="rfc.section.4.1.1.p.2"><ol><li>Let output be an empty string.</li><li>For each member mem of input_dictionary: <ol><li>Let name be the result of applying Serialising an Key (<a href="#ser-key" title="Serialising a Key">Section 4.1.1.1</a>) to mem’s member-name.</li><li>Append name to output.</li><li>Append “=” to output.</li><li>Let value be the result of applying Serialising an Item (<a href="#ser-item" title="Serialising an Item">Section 4.1.5</a>) to mem’s member-value.</li><li>Append value to output.</li><li>If more members remain in input_dictionary: <ol><li>Append a COMMA to output.</li><li>Append a single WS to output.</li></ol></li></ol></li><li>Return output.</li></ol></div><section id="ser-key"><h5 id="rfc.section.4.1.1.1"><a href="#rfc.section.4.1.1.1">4.1.1.1.</a> <a href="#ser-key">Serialising a Key</a></h5><div id="rfc.section.4.1.1.1.p.1" class="avoidbreakafter"><p>Given a key as input_key:</p></div><div id="rfc.section.4.1.1.1.p.2"><ol><li>If input_key is not a sequence of characters, or contains characters not allowed in the ABNF for key, fail serialisation.</li><li>Let output be an empty string.</li><li>Append input_key to output, using ASCII encoding <a href="#RFC0020"><cite title="ASCII format for network interchange">[RFC0020]</cite></a>.</li><li>Return output.</li></ol></div></section></section><section id="ser-list"><h4 id="rfc.section.4.1.2"><a href="#rfc.section.4.1.2">4.1.2.</a> <a href="#ser-list">Serialising a List</a></h4><div id="rfc.section.4.1.2.p.1" class="avoidbreakafter"><p>Given a list as input_list:</p></div><div id="rfc.section.4.1.2.p.2"><ol><li>Let output be an empty string.</li><li>For each member mem of input_list: <ol><li>Let value be the result of applying Serialising an Item (<a href="#ser-item" title="Serialising an Item">Section 4.1.5</a>) to mem.</li><li>Append value to output.</li><li>If more members remain in input_list: <ol><li>Append a COMMA to output.</li><li>Append a single WS to output.</li></ol></li></ol></li><li>Return output.</li></ol></div></section><section id="ser-listlist"><h4 id="rfc.section.4.1.3"><a href="#rfc.section.4.1.3">4.1.3.</a> <a href="#ser-listlist">Serialising a List of Lists</a></h4><div id="rfc.section.4.1.3.p.1" class="avoidbreakafter"><p>Given a list of lists of items as input_list:</p></div><div id="rfc.section.4.1.3.p.2"><ol><li>Let output be an empty string.</li><li>For each member inner_list of input_list: <ol><li>If inner_list is not a list, fail serialisation.</li><li>If inner_list is empty, fail serialisation.</li><li>For each inner_mem of inner_list: <ol><li>Let value be the result of applying Serialising an Item (<a href="#ser-item" title="Serialising an Item">Section 4.1.5</a>) to inner_mem.</li><li>Append value to output.</li><li>If more members remain in inner_list: <ol><li>Append a “;” to output.</li><li>Append a single WS to output.</li></ol></li></ol></li><li>If more members remain in input_list: <ol><li>Append a COMMA to output.</li><li>Append a single WS to output.</li></ol></li></ol></li><li>Return output.</li></ol></div></section><section id="ser-param-list"><h4 id="rfc.section.4.1.4"><a href="#rfc.section.4.1.4">4.1.4.</a> <a href="#ser-param-list">Serialising a Parameterised List</a></h4><div id="rfc.section.4.1.4.p.1" class="avoidbreakafter"><p>Given a parameterised list as input_plist:</p></div><div id="rfc.section.4.1.4.p.2"><ol><li>Let output be an empty string.</li><li>For each member mem of input_plist: <ol><li>Let id be the result of applying Serialising a Token (<a href="#ser-token" title="Serialising a Token">Section 4.1.9</a>) to mem’s token.</li><li>Append id to output.</li><li>For each parameter in mem’s parameters: <ol><li>Append “;” to output.</li><li>Let name be the result of applying Serialising a Key (<a href="#ser-key" title="Serialising a Key">Section 4.1.1.1</a>) to parameter’s param-name.</li><li>Append name to output.</li><li>If parameter has a param-value: <ol><li>Let value be the result of applying Serialising an Item (<a href="#ser-item" title="Serialising an Item">Section 4.1.5</a>) to parameter’s param-value.</li><li>Append “=” to output.</li><li>Append value to output.</li></ol></li></ol></li><li>If more members remain in input_plist: <ol><li>Append a COMMA to output.</li><li>Append a single WS to output.</li></ol></li></ol></li><li>Return output.</li></ol></div></section><section id="ser-item"><h4 id="rfc.section.4.1.5"><a href="#rfc.section.4.1.5">4.1.5.</a> <a href="#ser-item">Serialising an Item</a></h4><div id="rfc.section.4.1.5.p.1" class="avoidbreakafter"><p>Given an item as input_item:</p></div><div id="rfc.section.4.1.5.p.2"><ol><li>If input_item is an integer, return the result of applying Serialising an Integer (<a href="#ser-integer" title="Serialising an Integer">Section 4.1.6</a>) to input_item.</li><li>If input_item is a float, return the result of applying Serialising a Float (<a href="#ser-float" title="Serialising a Float">Section 4.1.7</a>) to input_item.</li><li>If input_item is a string, return the result of applying Serialising a String (<a href="#ser-string" title="Serialising a String">Section 4.1.8</a>) to input_item.</li><li>If input_item is a token, return the result of Serialising a Token (<a href="#ser-token" title="Serialising a Token">Section 4.1.9</a>) to input_item.</li><li>If input_item is a Boolean, return the result of applying Serialising a Boolean (<a href="#ser-boolean" title="Serialising a Boolean">Section 4.1.11</a>) to input_item.</li><li>If input_item is a byte sequence, return the result of applying Serialising a Byte Sequence (<a href="#ser-binary" title="Serialising a Byte Sequence">Section 4.1.10</a>) to input_item.</li><li>Otherwise, fail serialisation.</li></ol></div></section><section id="ser-integer"><h4 id="rfc.section.4.1.6"><a href="#rfc.section.4.1.6">4.1.6.</a> <a href="#ser-integer">Serialising an Integer</a></h4><div id="rfc.section.4.1.6.p.1" class="avoidbreakafter"><p>Given an integer as input_integer:</p></div><div id="rfc.section.4.1.6.p.2"><ol><li>If input_integer is not an integer in the range of −9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 inclusive, fail serialisation.</li><li>Let output be an empty string.</li><li>If input_integer is less than (but not equal to) 0, append “-“ to output.</li><li>Append input_integer’s numeric value represented in base 10 using only decimal digits to output.</li><li>Return output.</li></ol></div></section><section id="ser-float"><h4 id="rfc.section.4.1.7"><a href="#rfc.section.4.1.7">4.1.7.</a> <a href="#ser-float">Serialising a Float</a></h4><div id="rfc.section.4.1.7.p.1" class="avoidbreakafter"><p>Given a float as input_float:</p></div><div id="rfc.section.4.1.7.p.2"><ol><li>If input_float is not a IEEE 754 double precision number, fail serialisation.</li><li>Let output be an empty string.</li><li>If input_float is less than (but not equal to) 0, append “-“ to output.</li><li>Append input_float’s integer component represented in base 10 using only decimal digits to output; if it is zero, append “0”.</li><li>Append “.” to output.</li><li>Append input_float’s decimal component represented in base 10 using only decimal digits to output; if it is zero, append “0”.</li><li>Return output.</li></ol></div></section><section id="ser-string"><h4 id="rfc.section.4.1.8"><a href="#rfc.section.4.1.8">4.1.8.</a> <a href="#ser-string">Serialising a String</a></h4><div id="rfc.section.4.1.8.p.1" class="avoidbreakafter"><p>Given a string as input_string:</p></div><div id="rfc.section.4.1.8.p.2"><ol><li>If input_string is not a sequence of characters, or contains characters outside the range allowed by VCHAR or SP, fail serialisation.</li><li>Let output be an empty string.</li><li>Append DQUOTE to output.</li><li>For each character char in input_string: <ol><li>If char is “\” or DQUOTE: <ol><li>Append “\” to output.</li></ol></li><li>Append char to output, using ASCII encoding <a href="#RFC0020"><cite title="ASCII format for network interchange">[RFC0020]</cite></a>.</li></ol></li><li>Append DQUOTE to output.</li><li>Return output.</li></ol></div></section><section id="ser-token"><h4 id="rfc.section.4.1.9"><a href="#rfc.section.4.1.9">4.1.9.</a> <a href="#ser-token">Serialising a Token</a></h4><div id="rfc.section.4.1.9.p.1" class="avoidbreakafter"><p>Given a token as input_token:</p></div><div id="rfc.section.4.1.9.p.2"><ol><li>If input_token is not a sequence of characters, or contains characters not allowed in <a href="#token" title="Tokens">Section 3.9</a>}, fail serialisation.</li><li>Let output be an empty string.</li><li>Append input_token to output, using ASCII encoding <a href="#RFC0020"><cite title="ASCII format for network interchange">[RFC0020]</cite></a>.</li><li>Return output.</li></ol></div></section><section id="ser-binary"><h4 id="rfc.section.4.1.10"><a href="#rfc.section.4.1.10">4.1.10.</a> <a href="#ser-binary">Serialising a Byte Sequence</a></h4><div id="rfc.section.4.1.10.p.1" class="avoidbreakafter"><p>Given a byte sequence as input_bytes:</p></div><div id="rfc.section.4.1.10.p.2"><ol><li>If input_bytes is not a sequence of bytes, fail serialisation.</li><li>Let output be an empty string.</li><li>Append “*” to output.</li><li>Append the result of base64-encoding input_bytes as per <a href="#RFC4648"><cite title="The Base16, Base32, and Base64 Data Encodings">[RFC4648]</cite></a>, Section 4, taking account of the requirements below.</li><li>Append “*” to output.</li><li>Return output.</li></ol></div><div id="rfc.section.4.1.10.p.3"><p>The encoded data is required to be padded with “=”, as per <a href="#RFC4648"><cite title="The Base16, Base32, and Base64 Data Encodings">[RFC4648]</cite></a>, Section 3.2.</p></div><div id="rfc.section.4.1.10.p.4"><p>Likewise, encoded data SHOULD have pad bits set to zero, as per <a href="#RFC4648"><cite title="The Base16, Base32, and Base64 Data Encodings">[RFC4648]</cite></a>, Section 3.5, unless it is not possible to do so due to implementation constraints.</p></div></section><section id="ser-boolean"><h4 id="rfc.section.4.1.11"><a href="#rfc.section.4.1.11">4.1.11.</a> <a href="#ser-boolean">Serialising a Boolean</a></h4><div id="rfc.section.4.1.11.p.1" class="avoidbreakafter"><p>Given a Boolean as input_boolean:</p></div><div id="rfc.section.4.1.11.p.2"><ol><li>If input_boolean is not a boolean, fail serialisation.</li><li>Let output be an empty string.</li><li>Append “?” to output.</li><li>If input_boolean is true, append “T” to output.</li><li>If input_boolean is false, append “F” to output.</li><li>Return output.</li></ol></div></section></section><section id="text-parse"><h3 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2.</a> <a href="#text-parse">Parsing HTTP/1 Header Fields into Structured Headers</a></h3><div id="rfc.section.4.2.p.1"><p>When a receiving implementation parses textual HTTP header fields (e.g., in HTTP/1 or HTTP/2) that are known to be Structured Headers, it is important that care be taken, as there are a number of edge cases that can cause interoperability or even security problems. This section specifies the algorithm for doing so.</p></div><div id="rfc.section.4.2.p.2"><p>Given an ASCII string input_string that represents the chosen header’s field-value, and header_type, one of “dictionary”, “list”, “list-list”, “param-list”, or “item”, return the parsed header value.</p></div><div id="rfc.section.4.2.p.3"><ol><li>Discard any leading OWS from input_string.</li><li>If header_type is “dictionary”, let output be the result of Parsing a Dictionary from Text (<a href="#parse-dictionary" title="Parsing a Dictionary from Text">Section 4.2.1</a>).</li><li>If header_type is “list”, let output be the result of Parsing a List from Text (<a href="#parse-list" title="Parsing a List from Text">Section 4.2.3</a>).</li><li>If header_type is “list-list”, let output be the result of Parsing a List of Lists from Text (<a href="#parse-listlist" title="Parsing a List of Lists from Text">Section 4.2.4</a>).</li><li>If header_type is “param-list”, let output be the result of Parsing a Parameterised List from Text (<a href="#parse-param-list" title="Parsing a Parameterised List from Text">Section 4.2.5</a>).</li><li>If header_type is “item”, let output be the result of Parsing an Item from Text (<a href="#parse-item" title="Parsing an Item from Text">Section 4.2.7</a>).</li><li>Discard any leading OWS from input_string.</li><li>If input_string is not empty, fail parsing.</li><li>Otherwise, return output.</li></ol></div><div id="rfc.section.4.2.p.4"><p>When generating input_string, parsers MUST combine all instances of the target header field into one comma-separated field-value, as per <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>, Section 3.2.2; this assures that the header is processed correctly.</p></div><div id="rfc.section.4.2.p.5"><p>For Lists, Lists of Lists, Parameterised Lists and Dictionaries, this has the effect of correctly concatenating all instances of the header field, as long as individual individual members of the top-level data structure are not split across multiple header instances.</p></div><div id="rfc.section.4.2.p.6"><p>Strings split across multiple header instances will have unpredictable results, because comma(s) and whitespace inserted upon combination will become part of the string output by the parser. Since concatenation might be done by an upstream intermediary, the results are not under the control of the serialiser or the parser.</p></div><div id="rfc.section.4.2.p.7"><p>Integers, Floats and Byte Sequences cannot be split across multiple headers because the inserted commas will cause parsing to fail.</p></div><div id="rfc.section.4.2.p.8"><p>If parsing fails – including when calling another algorithm – the entire header field’s value MUST be discarded. This is intentionally strict, to improve interoperability and safety, and specifications referencing this document cannot loosen this requirement.</p></div><div id="rfc.section.4.2.p.9"><p>Note that this has the effect of discarding any header field with non-ASCII characters in input_string.</p></div><section id="parse-dictionary"><h4 id="rfc.section.4.2.1"><a href="#rfc.section.4.2.1">4.2.1.</a> <a href="#parse-dictionary">Parsing a Dictionary from Text</a></h4><div id="rfc.section.4.2.1.p.1"><p>Given an ASCII string input_string, return an ordered map of (key, item). input_string is modified to remove the parsed value.</p></div><div id="rfc.section.4.2.1.p.2"><ol><li>Let dictionary be an empty, ordered map.</li><li>While input_string is not empty: <ol><li>Let this_key be the result of running Parse a Key from Text (<a href="#parse-key" title="Parsing a Key from Text">Section 4.2.2</a>) with input_string.</li><li>If dictionary already contains this_key, fail parsing.</li><li>Consume the first character of input_string; if it is not “=”, fail parsing.</li><li>Let this_value be the result of running Parse Item from Text (<a href="#parse-item" title="Parsing an Item from Text">Section 4.2.7</a>) with input_string.</li><li>Add key this_key with value this_value to dictionary.</li><li>Discard any leading OWS from input_string.</li><li>If input_string is empty, return dictionary.</li><li>Consume the first character of input_string; if it is not COMMA, fail parsing.</li><li>Discard any leading OWS from input_string.</li><li>If input_string is empty, fail parsing.</li></ol></li><li>No structured data has been found; fail parsing.</li></ol></div></section><section id="parse-key"><h4 id="rfc.section.4.2.2"><a href="#rfc.section.4.2.2">4.2.2.</a> <a href="#parse-key">Parsing a Key from Text</a></h4><div id="rfc.section.4.2.2.p.1"><p>Given an ASCII string input_string, return a key. input_string is modified to remove the parsed value.</p></div><div id="rfc.section.4.2.2.p.2"><ol><li>If the first character of input_string is not lcalpha, fail parsing.</li><li>Let output_string be an empty string.</li><li>While input_string is not empty: <ol><li>Let char be the result of removing the first character of input_string.</li><li>If char is not one of lcalpha, DIGIT, “_”, or “-“: <ol><li>Prepend char to input_string.</li><li>Return output_string.</li></ol></li><li>Append char to output_string.</li></ol></li><li>Return output_string.</li></ol></div></section><section id="parse-list"><h4 id="rfc.section.4.2.3"><a href="#rfc.section.4.2.3">4.2.3.</a> <a href="#parse-list">Parsing a List from Text</a></h4><div id="rfc.section.4.2.3.p.1"><p>Given an ASCII string input_string, return a list of items. input_string is modified to remove the parsed value.</p></div><div id="rfc.section.4.2.3.p.2"><ol><li>Let items be an empty array.</li><li>While input_string is not empty: <ol><li>Let item be the result of running Parse Item from Text (<a href="#parse-item" title="Parsing an Item from Text">Section 4.2.7</a>) with input_string.</li><li>Append item to items.</li><li>Discard any leading OWS from input_string.</li><li>If input_string is empty, return items.</li><li>Consume the first character of input_string; if it is not COMMA, fail parsing.</li><li>Discard any leading OWS from input_string.</li><li>If input_string is empty, fail parsing.</li></ol></li><li>No structured data has been found; fail parsing.</li></ol></div></section><section id="parse-listlist"><h4 id="rfc.section.4.2.4"><a href="#rfc.section.4.2.4">4.2.4.</a> <a href="#parse-listlist">Parsing a List of Lists from Text</a></h4><div id="rfc.section.4.2.4.p.1"><p>Given an ASCII string input_string, return a list of lists of items. input_string is modified to remove the parsed value.</p></div><div id="rfc.section.4.2.4.p.2"><ol><li>let top_list be an empty array.</li><li>Let inner_list be an empty array.</li><li>While input_string is not empty: <ol><li>Let item be the result of running Parse Item from Text (<a href="#parse-item" title="Parsing an Item from Text">Section 4.2.7</a>) with input_string.</li><li>Append item to inner_list.</li><li>Discard any leading OWS from input_string.</li><li>If input_string is empty, append inner_list to top_list and return top_list.</li><li>Let char be the result of consuming the first character of input_string.</li><li>If char is COMMA: <ol><li>Append inner_list to top_list.</li><li>Let inner_list be an empty array.</li></ol></li><li>Else if char is not “;”, fail parsing.</li><li>Discard any leading OWS from input_string.</li><li>If input_string is empty, fail parsing.</li></ol></li><li>No structured data has been found; fail parsing.</li></ol></div></section><section id="parse-param-list"><h4 id="rfc.section.4.2.5"><a href="#rfc.section.4.2.5">4.2.5.</a> <a href="#parse-param-list">Parsing a Parameterised List from Text</a></h4><div id="rfc.section.4.2.5.p.1"><p>Given an ASCII string input_string, return a list of parameterised identifiers. input_string is modified to remove the parsed value.</p></div><div id="rfc.section.4.2.5.p.2"><ol><li>Let items be an empty array.</li><li>While input_string is not empty: <ol><li>Let item be the result of running Parse Parameterised Identifier from Text (<a href="#parse-param-id" title="Parsing a Parameterised Identifier from Text">Section 4.2.6</a>) with input_string.</li><li>Append item to items.</li><li>Discard any leading OWS from input_string.</li><li>If input_string is empty, return items.</li><li>Consume the first character of input_string; if it is not COMMA, fail parsing.</li><li>Discard any leading OWS from input_string.</li><li>If input_string is empty, fail parsing.</li></ol></li><li>No structured data has been found; fail parsing.</li></ol></div></section><section id="parse-param-id"><h4 id="rfc.section.4.2.6"><a href="#rfc.section.4.2.6">4.2.6.</a> <a href="#parse-param-id">Parsing a Parameterised Identifier from Text</a></h4><div id="rfc.section.4.2.6.p.1"><p>Given an ASCII string input_string, return an token with an unordered map of parameters. input_string is modified to remove the parsed value.</p></div><div id="rfc.section.4.2.6.p.2"><ol><li>Let primary_identifier be the result of Parsing a Token from Text (<a href="#parse-token" title="Parsing a Token from Text">Section 4.2.10</a>) from input_string.</li><li>Let parameters be an empty, unordered map.</li><li>In a loop: <ol><li>Discard any leading OWS from input_string.</li><li>If the first character of input_string is not “;”, exit the loop.</li><li>Consume a “;” character from the beginning of input_string.</li><li>Discard any leading OWS from input_string.</li><li>let param_name be the result of Parsing a key from Text (<a href="#parse-key" title="Parsing a Key from Text">Section 4.2.2</a>) from input_string.</li><li>If param_name is already present in parameters, fail parsing.</li><li>Let param_value be a null value.</li><li>If the first character of input_string is “=”: <ol><li>Consume the “=” character at the beginning of input_string.</li><li>Let param_value be the result of Parsing an Item from Text (<a href="#parse-item" title="Parsing an Item from Text">Section 4.2.7</a>) from input_string.</li></ol></li><li>Add key param_name with value param_value to parameters.</li></ol></li><li>Return the tuple (primary_identifier, parameters).</li></ol></div></section><section id="parse-item"><h4 id="rfc.section.4.2.7"><a href="#rfc.section.4.2.7">4.2.7.</a> <a href="#parse-item">Parsing an Item from Text</a></h4><div id="rfc.section.4.2.7.p.1"><p>Given an ASCII string input_string, return an item. input_string is modified to remove the parsed value.</p></div><div id="rfc.section.4.2.7.p.2"><ol><li>If the first character of input_string is a “-“ or a DIGIT, process input_string as a number (<a href="#parse-number" title="Parsing a Number from Text">Section 4.2.8</a>) and return the result.</li><li>If the first character of input_string is a DQUOTE, process input_string as a string (<a href="#parse-string" title="Parsing a String from Text">Section 4.2.9</a>) and return the result.</li><li>If the first character of input_string is “*”, process input_string as a byte sequence (<a href="#parse-binary" title="Parsing a Byte Sequence from Text">Section 4.2.11</a>) and return the result.</li><li>If the first character of input_string is “?”, process input_string as a Boolean (<a href="#parse-boolean" title="Parsing a Boolean from Text">Section 4.2.12</a>) and return the result.</li><li>If the first character of input_string is an ALPHA, process input_string as a token (<a href="#parse-token" title="Parsing a Token from Text">Section 4.2.10</a>) and return the result.</li><li>Otherwise, fail parsing.</li></ol></div></section><section id="parse-number"><h4 id="rfc.section.4.2.8"><a href="#rfc.section.4.2.8">4.2.8.</a> <a href="#parse-number">Parsing a Number from Text</a></h4><div id="rfc.section.4.2.8.p.1"><p>Given an ASCII string input_string, return a number. input_string is modified to remove the parsed value.</p></div><div id="rfc.section.4.2.8.p.2"><p>NOTE: This algorithm parses both Integers <a href="#integer" title="Integers">Section 3.6</a> and Floats <a href="#float" title="Floats">Section 3.7</a>, and returns the corresponding structure.</p></div><div id="rfc.section.4.2.8.p.3"><ol><li>Let type be “integer”.</li><li>Let sign be 1.</li><li>Let input_number be an empty string.</li><li>If the first character of input_string is “-“, remove it from input_string and set sign to -1.</li><li>If input_string is empty, fail parsing.</li><li>If the first character of input_string is not a DIGIT, fail parsing.</li><li>While input_string is not empty: <ol><li>Let char be the result of removing the first character of input_string.</li><li>If char is a DIGIT, append it to input_number.</li><li>Else, if type is “integer” and char is “.”, append char to input_number and set type to “float”.</li><li>Otherwise, prepend char to input_string, and exit the loop.</li><li>If type is “integer” and input_number contains more than 19 characters, fail parsing.</li><li>If type is “float” and input_number contains more than 16 characters, fail parsing.</li></ol></li><li>If type is “integer”: <ol><li>Parse input_number as an integer and let output_number be the product of the result and sign.</li><li>If output_number is outside the range defined in <a href="#integer" title="Integers">Section 3.6</a>, fail parsing.</li></ol></li><li>Otherwise: <ol><li>If the final character of input_number is “.”, fail parsing.</li><li>Parse input_number as a float and let output_number be the product of the result and sign.</li></ol></li><li>Return output_number.</li></ol></div></section><section id="parse-string"><h4 id="rfc.section.4.2.9"><a href="#rfc.section.4.2.9">4.2.9.</a> <a href="#parse-string">Parsing a String from Text</a></h4><div id="rfc.section.4.2.9.p.1"><p>Given an ASCII string input_string, return an unquoted string. input_string is modified to remove the parsed value.</p></div><div id="rfc.section.4.2.9.p.2"><ol><li>Let output_string be an empty string.</li><li>If the first character of input_string is not DQUOTE, fail parsing.</li><li>Discard the first character of input_string.</li><li>While input_string is not empty: <ol><li>Let char be the result of removing the first character of input_string.</li><li>If char is a backslash (“\”): <ol><li>If input_string is now empty, fail parsing.</li><li>Else: <ol><li>Let next_char be the result of removing the first character of input_string.</li><li>If next_char is not DQUOTE or “\”, fail parsing.</li><li>Append next_char to output_string.</li></ol></li></ol></li><li>Else, if char is DQUOTE, return output_string.</li><li>Else, if char is in the range %x00-1f or %x7f (i.e., is not in VCHAR or SP), fail parsing.</li><li>Else, append char to output_string.</li></ol></li><li>Reached the end of input_string without finding a closing DQUOTE; fail parsing.</li></ol></div></section><section id="parse-token"><h4 id="rfc.section.4.2.10"><a href="#rfc.section.4.2.10">4.2.10.</a> <a href="#parse-token">Parsing a Token from Text</a></h4><div id="rfc.section.4.2.10.p.1"><p>Given an ASCII string input_string, return a token. input_string is modified to remove the parsed value.</p></div><div id="rfc.section.4.2.10.p.2"><ol><li>If the first character of input_string is not ALPHA, fail parsing.</li><li>Let output_string be an empty string.</li><li>While input_string is not empty: <ol><li>Let char be the result of removing the first character of input_string.</li><li>If char is not one of ALPHA, DIGIT, “_”, “-“, “.”, “:”, “%”, “*” or “/”: <ol><li>Prepend char to input_string.</li><li>Return output_string.</li></ol></li><li>Append char to output_string.</li></ol></li><li>Return output_string.</li></ol></div></section><section id="parse-binary"><h4 id="rfc.section.4.2.11"><a href="#rfc.section.4.2.11">4.2.11.</a> <a href="#parse-binary">Parsing a Byte Sequence from Text</a></h4><div id="rfc.section.4.2.11.p.1"><p>Given an ASCII string input_string, return a byte sequence. input_string is modified to remove the parsed value.</p></div><div id="rfc.section.4.2.11.p.2"><ol><li>If the first character of input_string is not “*”, fail parsing.</li><li>Discard the first character of input_string.</li><li>If there is not a “*” character before the end of input_string, fail parsing.</li><li>Let b64_content be the result of removing content of input_string up to but not including the first instance of the character “*”.</li><li>Consume the “*” character at the beginning of input_string.</li><li>If b64_content contains a character not included in ALPHA, DIGIT, “+”, “/” and “=”, fail parsing.</li><li>Let binary_content be the result of Base 64 Decoding <a href="#RFC4648"><cite title="The Base16, Base32, and Base64 Data Encodings">[RFC4648]</cite></a> b64_content, synthesising padding if necessary (note the requirements about recipient behaviour below).</li><li>Return binary_content.</li></ol></div><div id="rfc.section.4.2.11.p.3"><p>Because some implementations of base64 do not allow reject of encoded data that is not properly “=” padded (see <a href="#RFC4648"><cite title="The Base16, Base32, and Base64 Data Encodings">[RFC4648]</cite></a>, Section 3.2), parsers SHOULD NOT fail when it is not present, unless they cannot be configured to do so.</p></div><div id="rfc.section.4.2.11.p.4"><p>Because some implementations of base64 do not allow rejection of encoded data that has non-zero pad bits (see <a href="#RFC4648"><cite title="The Base16, Base32, and Base64 Data Encodings">[RFC4648]</cite></a>, Section 3.5), parsers SHOULD NOT fail when it is present, unless they cannot be configured to do so.</p></div><div id="rfc.section.4.2.11.p.5"><p>This specification does not relax the requirements in <a href="#RFC4648"><cite title="The Base16, Base32, and Base64 Data Encodings">[RFC4648]</cite></a>, Section 3.1 and 3.3; therefore, parsers MUST fail on characters outside the base64 alphabet, and on line feeds in encoded data.</p></div></section><section id="parse-boolean"><h4 id="rfc.section.4.2.12"><a href="#rfc.section.4.2.12">4.2.12.</a> <a href="#parse-boolean">Parsing a Boolean from Text</a></h4><div id="rfc.section.4.2.12.p.1"><p>Given an ASCII string input_string, return a Boolean. input_string is modified to remove the parsed value.</p></div><div id="rfc.section.4.2.12.p.2"><ol><li>If the first character of input_string is not “?”, fail parsing.</li><li>Discard the first character of input_string.</li><li>If the first character of input_string case-sensitively matches “T”, discard the first character, and return true.</li><li>If the first character of input_string case-sensitively matches “F”, discard the first character, and return false.</li><li>No value has matched; fail parsing.</li></ol></div></section></section></section><section id="iana-considerations"><h2 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#iana-considerations">IANA Considerations</a></h2><div id="rfc.section.5.p.1"><p>This draft has no actions for IANA.</p></div></section><section id="security-considerations"><h2 id="rfc.section.6"><a href="#rfc.section.6">6.</a> <a href="#security-considerations">Security Considerations</a></h2><div id="rfc.section.6.p.1"><p>The size of most types defined by Structured Headers is not limited; as a result, extremely large header fields could be an attack vector (e.g., for resource consumption). Most HTTP implementations limit the sizes of size of individual header fields as well as the overall header block size to mitigate such attacks.</p></div><div id="rfc.section.6.p.2"><p>It is possible for parties with the ability to inject new HTTP header fields to change the meaning of a Structured Header. In some circumstances, this will cause parsing to fail, but it is not possible to reliably fail in all such circumstances.</p></div></section><section id="rfc.references"><h2 id="rfc.section.7"><a href="#rfc.section.7">7.</a> References</h2><section><div id="rfc.references.1"><h3 id="rfc.section.7.1"><a href="#rfc.section.7.1">7.1.</a> Normative References</h3><dl class="reference"><dt id="RFC0020">[RFC0020]</dt><dd>Cerf, V., “<a href="https://tools.ietf.org/html/rfc20">ASCII format for network interchange</a>”, STD 80, RFC 20, <a href="http://dx.doi.org/10.17487/RFC0020">DOI 10.17487/RFC0020</a>, October 1969, &lt;<a href="https://www.rfc-editor.org/info/rfc20">https://www.rfc-editor.org/info/rfc20</a>&gt;.</dd><dt id="RFC2119">[RFC2119]</dt><dd>Bradner, S., “<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>”, BCP 14, RFC 2119, <a href="http://dx.doi.org/10.17487/RFC2119">DOI 10.17487/RFC2119</a>, March 1997, &lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;.</dd><dt id="RFC4648">[RFC4648]</dt><dd>Josefsson, S., “<a href="https://tools.ietf.org/html/rfc4648">The Base16, Base32, and Base64 Data Encodings</a>”, RFC 4648, <a href="http://dx.doi.org/10.17487/RFC4648">DOI 10.17487/RFC4648</a>, October 2006, &lt;<a href="https://www.rfc-editor.org/info/rfc4648">https://www.rfc-editor.org/info/rfc4648</a>&gt;.</dd><dt id="RFC5234">[RFC5234]</dt><dd>Crocker, D., Ed. and P. Overell, “<a href="https://tools.ietf.org/html/rfc5234">Augmented BNF for Syntax Specifications: ABNF</a>”, STD 68, RFC 5234, <a href="http://dx.doi.org/10.17487/RFC5234">DOI 10.17487/RFC5234</a>, January 2008, &lt;<a href="https://www.rfc-editor.org/info/rfc5234">https://www.rfc-editor.org/info/rfc5234</a>&gt;.</dd><dt id="RFC7230">[RFC7230]</dt><dd>Fielding, R., Ed. and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7230">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a>”, RFC 7230, <a href="http://dx.doi.org/10.17487/RFC7230">DOI 10.17487/RFC7230</a>, June 2014, &lt;<a href="https://www.rfc-editor.org/info/rfc7230">https://www.rfc-editor.org/info/rfc7230</a>&gt;.</dd><dt id="RFC8174">[RFC8174]</dt><dd>Leiba, B., “<a href="https://tools.ietf.org/html/rfc8174">Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</a>”, BCP 14, RFC 8174, <a href="http://dx.doi.org/10.17487/RFC8174">DOI 10.17487/RFC8174</a>, May 2017, &lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;.</dd></dl></div></section><section><div id="rfc.references.2"><h3 id="rfc.section.7.2"><a href="#rfc.section.7.2">7.2.</a> Informative References</h3><dl class="reference"><dt id="IEEE754">[IEEE754]</dt><dd>IEEE, “<a href="http://ieeexplore.ieee.org/document/4610935/">IEEE Standard for Floating-Point Arithmetic</a>”, IEEE 754-2008, <a href="http://dx.doi.org/10.1109/IEEESTD.2008.4610935">DOI 10.1109/IEEESTD.2008.4610935</a>, <a href="https://www.worldcat.org/search?q=isbn:9780738157528">ISBN 978-0-7381-5752-8</a>, August 2008, &lt;<a href="http://ieeexplore.ieee.org/document/4610935/">http://ieeexplore.ieee.org/document/4610935/</a>&gt;.<br>See also <a href="http://grouper.ieee.org/groups/754/">http://grouper.ieee.org/groups/754/</a>.</dd><dt id="RFC7231">[RFC7231]</dt><dd>Fielding, R., Ed. and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7231">Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</a>”, RFC 7231, <a href="http://dx.doi.org/10.17487/RFC7231">DOI 10.17487/RFC7231</a>, June 2014, &lt;<a href="https://www.rfc-editor.org/info/rfc7231">https://www.rfc-editor.org/info/rfc7231</a>&gt;.</dd><dt id="RFC7493">[RFC7493]</dt><dd>Bray, T., Ed., “<a href="https://tools.ietf.org/html/rfc7493">The I-JSON Message Format</a>”, RFC 7493, <a href="http://dx.doi.org/10.17487/RFC7493">DOI 10.17487/RFC7493</a>, March 2015, &lt;<a href="https://www.rfc-editor.org/info/rfc7493">https://www.rfc-editor.org/info/rfc7493</a>&gt;.</dd><dt id="RFC7540">[RFC7540]</dt><dd>Belshe, M., Peon, R., and M. Thomson, Ed., “<a href="https://tools.ietf.org/html/rfc7540">Hypertext Transfer Protocol Version 2 (HTTP/2)</a>”, RFC 7540, <a href="http://dx.doi.org/10.17487/RFC7540">DOI 10.17487/RFC7540</a>, May 2015, &lt;<a href="https://www.rfc-editor.org/info/rfc7540">https://www.rfc-editor.org/info/rfc7540</a>&gt;.</dd><dt id="RFC7541">[RFC7541]</dt><dd>Peon, R. and H. Ruellan, “<a href="https://tools.ietf.org/html/rfc7541">HPACK: Header Compression for HTTP/2</a>”, RFC 7541, <a href="http://dx.doi.org/10.17487/RFC7541">DOI 10.17487/RFC7541</a>, May 2015, &lt;<a href="https://www.rfc-editor.org/info/rfc7541">https://www.rfc-editor.org/info/rfc7541</a>&gt;.</dd><dt id="RFC8259">[RFC8259]</dt><dd>Bray, T., Ed., “<a href="https://tools.ietf.org/html/rfc8259">The JavaScript Object Notation (JSON) Data Interchange Format</a>”, STD 90, RFC 8259, <a href="http://dx.doi.org/10.17487/RFC8259">DOI 10.17487/RFC8259</a>, December 2017, &lt;<a href="https://www.rfc-editor.org/info/rfc8259">https://www.rfc-editor.org/info/rfc8259</a>&gt;.</dd></dl></div></section></section><section id="acknowledgements"><h2 id="rfc.section.A" class="np"><a href="#rfc.section.A">A.</a> <a href="#acknowledgements">Acknowledgements</a></h2><div id="rfc.section.A.p.1"><p>Many thanks to Matthew Kerwin for his detailed feedback and careful consideration during the development of this specification.</p></div></section><section id="faq"><h2 id="rfc.section.B"><a href="#rfc.section.B">B.</a> <a href="#faq">Frequently Asked Questions</a></h2><section id="why-not-json"><h3 id="rfc.section.B.1"><a href="#rfc.section.B.1">B.1.</a> <a href="#why-not-json">Why not JSON?</a></h3><div id="rfc.section.B.1.p.1"><p>Earlier proposals for structured headers were based upon JSON <a href="#RFC8259"><cite title="The JavaScript Object Notation (JSON) Data Interchange Format">[RFC8259]</cite></a>. However, constraining its use to make it suitable for HTTP header fields required senders and recipients to implement specific additional handling.</p></div><div id="rfc.section.B.1.p.2"><p>For example, JSON has specification issues around large numbers and objects with duplicate members. Although advice for avoiding these issues is available (e.g., <a href="#RFC7493"><cite title="The I-JSON Message Format">[RFC7493]</cite></a>), it cannot be relied upon.</p></div><div id="rfc.section.B.1.p.3"><p>Likewise, JSON strings are by default Unicode strings, which have a number of potential interoperability issues (e.g., in comparison). Although implementers can be advised to avoid non-ASCII content where unnecessary, this is difficult to enforce.</p></div><div id="rfc.section.B.1.p.4"><p>Another example is JSON’s ability to nest content to arbitrary depths. Since the resulting memory commitment might be unsuitable (e.g., in embedded and other limited server deployments), it’s necessary to limit it in some fashion; however, existing JSON implementations have no such limits, and even if a limit is specified, it’s likely that some header field definition will find a need to violate it.</p></div><div id="rfc.section.B.1.p.5"><p>Because of JSON’s broad adoption and implementation, it is difficult to impose such additional constraints across all implementations; some deployments would fail to enforce them, thereby harming interoperability.</p></div><div id="rfc.section.B.1.p.6"><p>Since a major goal for Structured Headers is to improve interoperability and simplify implementation, these concerns led to a format that requires a dedicated parser and serialiser.</p></div><div id="rfc.section.B.1.p.7"><p>Additionally, there were widely shared feelings that JSON doesn’t “look right” in HTTP headers.</p></div></section><section id="structured-headers-dont-fit-my-data"><h3 id="rfc.section.B.2"><a href="#rfc.section.B.2">B.2.</a> <a href="#structured-headers-dont-fit-my-data">Structured Headers don’t “fit” my data.</a></h3><div id="rfc.section.B.2.p.1"><p>Structured headers intentionally limits the complexity of data structures, to assure that it can be processed in a performant manner with little overhead. This means that work is necessary to fit some data types into them.</p></div><div id="rfc.section.B.2.p.2" class="avoidbreakafter"><p>Sometimes, this can be achieved by creating limited substructures in values, and/or using more than one header. For example, consider:</p></div><div id="rfc.figure.u.22"><pre>
Example-Thing: name="Widget", cost=89.2, descriptions="foo bar"
Example-Description: foo; url="https://example.net"; context=123,
                     bar; url="https://example.org"; context=456
</pre></div><div id="rfc.section.B.2.p.3"><p>Since the description contains a list of key/value pairs, we use a Parameterised List to represent them, with the token for each item in the list used to identify it in the “descriptions” member of the Example-Thing header.</p></div><div id="rfc.section.B.2.p.4"><p>When specifying more than one header, it’s important to remember to describe what a processor’s behaviour should be when one of the headers is missing.</p></div><div id="rfc.section.B.2.p.5"><p>If you need to fit arbitrarily complex data into a header, Structured Headers is probably a poor fit for your use case.</p></div></section><section id="what-should-generic-structured-headers-implementations-expose"><h3 id="rfc.section.B.3"><a href="#rfc.section.B.3">B.3.</a> <a href="#what-should-generic-structured-headers-implementations-expose">What should generic Structured Headers implementations expose?</a></h3><div id="rfc.section.B.3.p.1"><p>A generic implementation should expose the top-level parse (<a href="#text-parse" title="Parsing HTTP/1 Header Fields into Structured Headers">Section 4.2</a>) and serialise (<a href="#text-serialise" title="Serialising Structured Headers into HTTP/1">Section 4.1</a>) functions. They need not be functions; for example, it could be implemented as an object, with methods for each of the different top-level types.</p></div><div id="rfc.section.B.3.p.2"><p>For interoperability, it’s important that generic implementations be complete and follow the algorithms closely; see <a href="#strict" title="Intentionally Strict Processing">Section 1.1</a>. To aid this, a common test suite is being maintained by the community; see <a href="https://github.com/httpwg/structured-header-tests">https://github.com/httpwg/structured-header-tests</a>.</p></div></section></section><section id="changes"><h2 id="rfc.section.C"><a href="#rfc.section.C">C.</a> <a href="#changes">Changes</a></h2><div id="rfc.section.C.p.1"><p><em>RFC Editor: Please remove this section before publication.</em></p></div><section id="since-draft-ietf-httpbis-header-structure-08"><h3 id="rfc.section.C.1"><a href="#rfc.section.C.1">C.1.</a> <a href="#since-draft-ietf-httpbis-header-structure-08">Since draft-ietf-httpbis-header-structure-08</a></h3><div id="rfc.section.C.1.p.1"><ul><li>Disallow whitespace before items properly (#703).</li><li>Created “key” for use in dictionaries and parameters, rather than relying on identifier (#702). Identifiers have a separate minimum supported size.</li><li>Expanded the range of special characters allowed in identifier to include all of ALPHA, “.”, “:”, and “%” (#702).</li><li>Use “?” instead of “!” to indicate a Boolean (#719).</li><li>Added “Intentionally Strict Processing” (#684).</li><li>Gave better names for referring specs to use in Parameterised Lists (#720).</li><li>Added Lists of Lists (#721).</li><li>Rename Identifier to Token (#725).</li><li>Add implementation guidance (#727).</li></ul></div></section><section id="since-draft-ietf-httpbis-header-structure-07"><h3 id="rfc.section.C.2"><a href="#rfc.section.C.2">C.2.</a> <a href="#since-draft-ietf-httpbis-header-structure-07">Since draft-ietf-httpbis-header-structure-07</a></h3><div id="rfc.section.C.2.p.1"><ul><li>Make Dictionaries ordered mappings (#659).</li><li>Changed “binary content” to “byte sequence” to align with Infra specification (#671).</li><li>Changed “mapping” to “map” for #671.</li><li>Don’t fail if byte sequences aren’t “=” padded (#658).</li><li>Add Booleans (#683).</li><li>Allow identifiers in items again (#629).</li><li>Disallowed whitespace before items (#703).</li><li>Explain the consequences of splitting a string across multiple headers (#686).</li></ul></div></section><section id="since-draft-ietf-httpbis-header-structure-06"><h3 id="rfc.section.C.3"><a href="#rfc.section.C.3">C.3.</a> <a href="#since-draft-ietf-httpbis-header-structure-06">Since draft-ietf-httpbis-header-structure-06</a></h3><div id="rfc.section.C.3.p.1"><ul><li>Add a FAQ.</li><li>Allow non-zero pad bits.</li><li>Explicitly check for integers that violate constraints.</li></ul></div></section><section id="since-draft-ietf-httpbis-header-structure-05"><h3 id="rfc.section.C.4"><a href="#rfc.section.C.4">C.4.</a> <a href="#since-draft-ietf-httpbis-header-structure-05">Since draft-ietf-httpbis-header-structure-05</a></h3><div id="rfc.section.C.4.p.1"><ul><li>Reorganise specification to separate parsing out.</li><li>Allow referencing specs to use ABNF.</li><li>Define serialisation algorithms.</li><li>Refine relationship between ABNF, parsing and serialisation algorithms.</li></ul></div></section><section id="since-draft-ietf-httpbis-header-structure-04"><h3 id="rfc.section.C.5"><a href="#rfc.section.C.5">C.5.</a> <a href="#since-draft-ietf-httpbis-header-structure-04">Since draft-ietf-httpbis-header-structure-04</a></h3><div id="rfc.section.C.5.p.1"><ul><li>Remove identifiers from item.</li><li>Remove most limits on sizes.</li><li>Refine number parsing.</li></ul></div></section><section id="since-draft-ietf-httpbis-header-structure-03"><h3 id="rfc.section.C.6"><a href="#rfc.section.C.6">C.6.</a> <a href="#since-draft-ietf-httpbis-header-structure-03">Since draft-ietf-httpbis-header-structure-03</a></h3><div id="rfc.section.C.6.p.1"><ul><li>Strengthen language around failure handling.</li></ul></div></section><section id="since-draft-ietf-httpbis-header-structure-02"><h3 id="rfc.section.C.7"><a href="#rfc.section.C.7">C.7.</a> <a href="#since-draft-ietf-httpbis-header-structure-02">Since draft-ietf-httpbis-header-structure-02</a></h3><div id="rfc.section.C.7.p.1"><ul><li>Split Numbers into Integers and Floats.</li><li>Define number parsing.</li><li>Tighten up binary parsing and give it an explicit end delimiter.</li><li>Clarify that mappings are unordered.</li><li>Allow zero-length strings.</li><li>Improve string parsing algorithm.</li><li>Improve limits in algorithms.</li><li>Require parsers to combine header fields before processing.</li><li>Throw an error on trailing garbage.</li></ul></div></section><section id="since-draft-ietf-httpbis-header-structure-01"><h3 id="rfc.section.C.8"><a href="#rfc.section.C.8">C.8.</a> <a href="#since-draft-ietf-httpbis-header-structure-01">Since draft-ietf-httpbis-header-structure-01</a></h3><div id="rfc.section.C.8.p.1"><ul><li>Replaced with draft-nottingham-structured-headers.</li></ul></div></section><section id="since-draft-ietf-httpbis-header-structure-00"><h3 id="rfc.section.C.9"><a href="#rfc.section.C.9">C.9.</a> <a href="#since-draft-ietf-httpbis-header-structure-00">Since draft-ietf-httpbis-header-structure-00</a></h3><div id="rfc.section.C.9.p.1"><ul><li>Added signed 64bit integer type.</li><li>Drop UTF8, and settle on BCP137 ::EmbeddedUnicodeChar for h1-unicode-string.</li><li>Change h1_blob delimiter to “:” since “’” is valid t_char</li></ul></div></section></section><section id="rfc.authors" class="avoidbreakinside"><h2><a href="#rfc.authors">Authors' Addresses</a></h2><address><b>Mark Nottingham</b><br>Fastly<br>EMail: <a href="mailto:mnot@mnot.net">mnot@mnot.net</a><br>URI: <a href="https://www.mnot.net/">https://www.mnot.net/</a></address><address><b>Poul-Henning Kamp</b><br>The Varnish Cache Project<br>EMail: <a href="mailto:phk@varnish-cache.org">phk@varnish-cache.org</a></address></section></body></html>
